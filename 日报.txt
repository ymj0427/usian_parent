2020.6.1日报
  ElasticSearch介绍
     什么是elasticsearch?
  	    elasticsearch是基于lucene的全文检索服务器，对外提供restful接口

     elasticsearch原理
  	    正排索引：查字典时从第一页开始找，直到找到关键字为止（CTRL+F）
  	    倒排索引：查字典时通过目录查找

  	 逻辑结构：一个倒排索引表，由三部分组成
  		document
  		term
  		term----关联----document
  安装：ElasticSearch、Kibana、head
     index管理：
        创建index
          PUT /java1906
            {
              "settings": {
                "number_of_shards": 2,
                "number_of_replicas": 0
              }
            }
        修改index
          PUT /java1906/_settings
            {
              "number_of_replicas" : 1
            }
        删除index
          DELETE /java1906 [, other_index]
     mapping管理
        创建mapping
          POST index_name/type_name/_mapping
        查询mapping
          GET /java1906/course/_mapping
     document管理
        创建document
            Post语法：POST/index_name/type_name{fieldname:fieldvalue}
            Put语法：PUT/index_name/type_name/id{field_name:field_value}
        查询document
            GET /index_name/type_name/id或
            GET /index_name/type_name/_search?q=field_name:field_value
        删除document
            语法：DELETE/index_name/type_name/id


2020.6.2日报
   IK分词器
      安装
    	解压到plugs目录下，并重命名为ik

      自定义词库
    	IkAnalyzer.cfg.xml：配置扩展词典和停用词典
    	main.dic：扩展词典
    	stopwords.dic：停用词典

      两种分词模式
    	ik_smart：粗粒度拆分
    	ik_max_word：细粒度拆分

   field详细介绍
      field的属性
    	type：field的类型
    	analyzer：分词模式、ik_smart、ik_max_word
    	index：创建doucument和分词列表
    	field索引不存储：
    		"_source":{
    			"excludes":{"description"}
    		}

      常用的field类型
    	文本字段：text

    	关键字字段：keyword 索引时不分词

    	日期字段：date

    	数字字段：long、integer、double、float

      field属性设置的标准
    			    标准
    		分词         是否有意义
    		索引         是否搜索
    		存储         是否展示
   springboot整合ES
     整合步骤
    	1、pom.xml
    		elasticsearch、elasticsearch-rest-high-level-client

    	2、application.yml
    		spring:
    		  data:
    		    elasticsearch:
    		      cluster-nodes: 192.168.233.134:9200
    	3、config
    		@Configuration
    		public class ElasticsearchConfig extends ElasticsearchProperties{

    			@Bean
    			public RestHighLevelClient getRestHighLevelClient() {
    			String[] hosts = getClusterNodes().split(",");
    			HttpHost[] httpHosts = new HttpHost[hosts.length];
    			for (int i = 0; i < httpHosts.length; i++) {
    			    String h = hosts[i];
    			    httpHosts[i] = new HttpHost(h.split(":")[0],
    							Integer.parseInt(h.split(":")[1]));
    			}
    				return new RestHighLevelClient(RestClient.builder(httpHosts));
    			}
    		}

     删除索引库
        DeleteIndexRequest deleteIndexRequest = new DeleteIndexRequest("java1906");
    	restHighLevelClient.indices().delete(deleteIndexRequest,RequestOptions.DEFAULT);
     创建索引库
    	CreateIndexRequest createIndexRequest = new CreateIndexRequest("java1906");
    	restHighLevelClient.indices().create(createIndexRequest,RequestOptions.DEFAULT)


2020.6.3日报
     添加文档
        IndexRequest indexRequest = new IndexRequest("java1906", "course", "1");
        restHighLevelClient.index(indexRequest,RequestOptions.DEFAULT);
     批量添加文档
        bulkRequest.add(new IndexRequest("java1906", "course","2").source("{\"name\":\"php实战\",\"description\":\"php谁都不服\",\"studymodel\":\"201001\",\"price\":\"5.6\"}", XContentType.JSON));
       	bulkRequest.add(new IndexRequest("java1906", "course","3").source("{\"name\":\"net实战\",\"description\":\"net从入门到放弃\",\"studymodel\":\"201001\",\"price\":\"7.6\"}", XContentType.JSON));
        restHighLevelClient.bulk(bulkRequest,RequestOptions.DEFAULT);
     修改文档
         UpdateRequest updateRequest = new UpdateRequest("java1906", "course", "1");
         restHighLevelClient.update(updateRequest,RequestOptions.DEFAULT);
     删除文档
         DeleteRequest deleteRequest = new DeleteRequest("java1906","course","1");
         restHighLevelClient.delete(deleteRequest,RequestOptions.DEFAULT);
     查询文档
        GetRequest getRequest = new GetRequest("java1906","course","1");
        restHighLevelClient.get(getRequest,RequestOptions.DEFAULT);
     DSL查询
        match_all查询
        	SearchRequest searchRequest = new SearchRequest("java1906");
        	searchRequest.types("course");
        	SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
        	searchSourceBuilder.query(QueryBuilders.matchAllQuery());
        	searchRequest.search(searchSourceBuilder)
        	restHighLevelClient.search(searchRequest,RequestOptions.DEFAULT);
        分页查询
        	SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
        	searchSourceBuilder.query(QueryBuilders.matchAllQuery());
        	searchSourceBuilder.form(1);
        	searchSourceBuilder.size(2);
        	searchSourceBuilder.sort("price",SortOrder.DESC);
        match查询
            SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
            searchSourceBuilder.query(QueryBuilders.matchQuery("name", "spring开发").operator(Operator.AND));
            searchRequest.source(searchSourceBuilder);
            searchResponse = restHighLevelClient.search(searchRequest,RequestOptions.DEFAULT);
        multi_match查询
            SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
            searchSourceBuilder.query(QueryBuilders.multiMatchQuery("开发","name","description"));
            searchRequest.source(searchSourceBuilder);
            searchResponse = restHighLevelClient.search(searchRequest,RequestOptions.DEFAULT);
        bool查询
            SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
            BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
            boolQueryBuilder.must(QueryBuilders.matchQuery("name", "开发"));
            boolQueryBuilder.must(QueryBuilders.matchQuery("description","开发"));
            searchSourceBuilder.query(boolQueryBuilder);
            searchRequest.source(searchSourceBuilder);
            searchResponse = restHighLevelClient.search(searchRequest,RequestOptions.DEFAULT);
        filter查询
            SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
            BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
            boolQueryBuilder.must(QueryBuilders.matchQuery("name","开发"));
            boolQueryBuilder.filter(QueryBuilders.rangeQuery("price").gte(10).lte(100))
            searchSourceBuilder.query(boolQueryBuilder);
            searchRequest.source(searchSourceBuilder);
            searchResponse = restHighLevelClient.search(searchRequest,RequestOptions.DEFAULT);

2020.6.4日报
1、搭建ES集群
2、搜索展示的商品信息，将信息存入ES中

2020.6.5日报
    商品搜索
    usian_search_service
         SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
         HighlightBuilder highlightBuilder = new HighlightBuilder();
                    highlightBuilder.preTags("<font color='red'>");
                    highlightBuilder.postTags("</font>");
                    highlightBuilder.field("item_title");
                    searchSourceBuilder.highlighter(highlightBuilder);
    新增商品同步索引库
        common_mapper
            SearchItemMapper：SearchItem getItemById(Long itemId);
            SearchItemMapper.xml：
                        a.id,
                		a.title item_title,
                		a.sell_point item_sell_point,
                		a.price item_price,
                		a.image item_image,
                		b.name item_category_name,
                		c.item_desc item_desc
                	FROM
                		tb_item a
                	JOIN tb_item_cat b ON a.cid = b.id
                	JOIN tb_item_desc c ON a.id = c.item_id
                	WHERE a.status = 1
                	  AND a.id=#{itemId}
        usian_search_service
            pom：spring-boot-starter-amqp
            application.yml：
                spring:
                  rabbitmq:
                    host: 192.168.29.134
                    username: admin
                    password: 1111
                    virtual-host: /
            service：
                SearchItem searchItem = searchItemMapper.getItemById(Long.valueOf(itemId));
                IndexResponse indexResponse = restHighLevelClient.index(indexRequest,RequestOptions.DEFAULT);
            listerner：
                value = @Queue(value="search_queue",durable = "true"),
                exchange = @Exchange(value="item_exchage",type= ExchangeTypes.TOPIC),
                key= {"item.*"}
        usian_item_service
            pom.xml：spring-boot-starter-amqp
            application.yml：
                spring:
                  rabbitmq:
                    host: 192.168.233.132
                    username: admin
                    password: 1111
                    virtual-host: /

2020.6.8日报
    商品搜索
       方案一：thymeleaf页面静态化
             a、创建商品详情的thymeleaf模板
             b、创建RabbitMQ消费者，收到消息后生成静态页面（D:/detail/26774635180.html）
             c、搭建nginx服务器，返回静态页面

       方案二：redis
             a、redis缓存商品详情
                 1、先查询redis，如果有直接返回
                 2、再查询mysql，并把查询结果装到redis中再返回

             b、如何保证redis不满？redis中都是热点商品？
                设置商品的实现时间：86400

             c、怎么保存商品信息（数据类型）？
                ITEM_INFO:123456:BASE
                ITEM_INFO:123456:DESC
                ITEM_INFO:123456:PARAM
    缓存穿透
        概述：
            当用户很发起很多请求的时候，缓存都没有命中，于是都去请求了持久层数据库，这会给持久层数据库造成很大的压力。
        解决方案：
            当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间（避免控制占用更多的存储空间），之后再访问这个数据将会从缓存中获取，保护了后端数据源
    缓存击穿
        概述：
            缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个key不停进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。
        解决方案：
            1、设置热点数据永远不过期
            2、加分布式锁

2020.6.9日报
    1、注册信息校验
        /**
         * 对用户的注册信息(用户名与电话号码)做数据校验
         */
        @Override
        public boolean checkUserInfo(String checkValue, Integer checkFlag) {
            TbUserExample example = new TbUserExample();
            TbUserExample.Criteria criteria = example.createCriteria();
            // 1、查询条件根据参数动态生成：1、2分别代表username、phone
            if (checkFlag == 1) {
                criteria.andUsernameEqualTo(checkValue);
            } else if (checkFlag == 2) {
                criteria.andPhoneEqualTo(checkValue);
            }
            // 2、从tb_user表中查询数据
            List<TbUser> list = tbUserMapper.selectByExample(example);
            // 3、判断查询结果，如果查询到数据返回false。
            if (list == null || list.size() == 0) {
                // 4、如果没有返回true。
                return true;
            }
            // 5、如果有返回false。
            return false;
        }
    }
    2、用户注册
         /**
         * 用户注册
         */
        @Override
        public Integer userRegister(TbUser user) {
            //将密码做加密处理。
            String pwd = MD5Utils.digest(user.getPassword());
            user.setPassword(pwd);
            //补齐数据
            user.setCreated(new Date());
            user.setUpdated(new Date());
            return this.tbUserMapper.insert(user);
        }
    3、用户登录
        @Override
        public Map userLogin(String username, String password) {
            // 1、判断用户名密码是否正确。
            String pwd = MD5Utils.digest(password);
            TbUserExample example = new TbUserExample();
            TbUserExample.Criteria criteria = example.createCriteria();
            criteria.andUsernameEqualTo(username);
            criteria.andPasswordEqualTo(pwd);
            List<TbUser> userList = this.tbUserMapper.selectByExample(example);
            if(userList == null || userList.size() <= 0){
                return null;
            }
            TbUser tbUser = userList.get(0);
            // 2、登录成功后生成token。Token相当于原来的jsessionid，字符串，可以使用uuid。
            String token = UUID.randomUUID().toString();
            // 3、把用户信息保存到redis。Key就是token，value就是TbUser对象转换成json。
            tbUser.setPassword(null);
            redisClient.set(USER_INFO + ":" + token, tbUser);
            // 5、设置key的过期时间。模拟Session的过期时间。
            redisClient.expire(USER_INFO + ":" + token, SESSION_EXPIRE);

            Map<String,String> map = new HashMap<String,String>();
            map.put("token",token);
            map.put("userid",tbUser.getId().toString());
            map.put("username",tbUser.getUsername());
            return map;
        }
    4、通过token查询用户信息
        1、从url中取参数token
        2、根据token查询redis
        3、如果查询不到数据，前台删除cookie中的用户信息
        4、如果查询到数据，说明用户已经登录需要重置key的过期时间

         /**
         * 查询用户登录是否过期
         * @param token
         * @return
         */
        @Override
        public TbUser getUserByToken(String token) {
            TbUser tbUser = (TbUser) redisClient.get(USER_INFO + ":" + token);
            if(tbUser!=null){
                //需要重置key的过期时间。
                redisClient.expire(USER_INFO+":"+token,SESSION_EXPIRE);
                return tbUser;
            }
            return null;
        }

    5、退出登录
        /**
         * 用户退出登录
         * @param token
         */
        @Override
        public Boolean logOut(String token) {
           return redisClient.del(USER_INFO + ":" + token);
        }

2020.6.10日报
    购物车
        添加购物车商品
        展示购物车列表页面
        修改购物车商品数量
        删除购物车商品
    未登录状态下：
        从cookie中查询商品列表Map<itemId,TbItem> 商品购买数量使用TbItem的num保存
        ​	购物车已存在则直接返回
        ​   购物车不存在则创建空的购物车并返回
        添加商品到购物车：
        ​	如果购物车存在该商品，商品数量相加。
        ​	如果购物车不存在该商品，根据商品id查询商品信息并添加到购车列表
        把购车商品列表写入cookie。
        ​	读写cookie可以使用CookieUtils工具类实现

    登录状态下：
        使用redis存储商品列表，使用hash对购物车进行归类
        从redis中查询商品列表
        将商品添加大购物车中
        将购物车缓存到redis中


2020.6.16日报
    订单功能：
        身份认证功能：
               使用springmvc的拦截器拦截所有订单的请求
               2、业务逻辑
                    a)  从cookie中取token。
                    b) 根据token调用sso服务查询用户信息。
                    d) 如果查不到用户信息则跳转到登录页面。
                    e) 查询到用户信息放行。
               代码：
                    在结算之前判断用户是否登录
                    @Component
                    public class UserLoginInterceptor implements HandlerInterceptor {

                        @Autowired
                        private SSOServiceFeign ssoServiceFeign;

                        @Override
                        public boolean preHandle(HttpServletRequest request, HttpServletResponse
                                response, Object handler) throws Exception {
                            //对用户的 token 做判断
                            String token = request.getParameter("token");
                            if (StringUtils.isBlank(token)) {
                                return false;
                            }
                            //如果用户 token 不为空，则校验用户在 redis 中是否失效
                            TbUser tbUser = ssoServiceFeign.getUserByToken(token);
                            if (tbUser == null) {
                                return false;
                            }
                            return true;
                        }
                    }

                    /**
                     * 拦截器配置类
                     */
                    @Configuration
                    public class WebConfig implements WebMvcConfigurer {
                        @Autowired
                        private UserLoginInterceptor userLoginInterceptor;

                        /**
                         * 注册拦截器
                         * @param registry
                         */
                        @Override
                        public void addInterceptors(InterceptorRegistry registry) {
                            InterceptorRegistration registration =
                                    registry.addInterceptor(this.userLoginInterceptor);
                            //拦截那个 URI
                            registration.addPathPatterns("/frontend/order/**");
                        }
                    }

         展示订单确认页面：
                1、在购物车页面点击“去结算”按钮跳转到订单确认页面。
                2、请求的url：/frontend/order/goSettlement
                3、参数：ids，userId
                4、查询redis中的购物车数据并返回给前端
                5、配送地址列表，需要用户登录。需要根据用户id查询收货地址列表。静态数据。
                6、支付方式。静态数据。

                /**
                 * 订单服务 Controller
                 */
                @RestController
                @RequestMapping("/frontend/order")
                public class OrderController {

                    @Autowired
                    private CartServiceFeign cartServiceFeign;

                    @Autowired
                    private OrderServiceFeign orderServiceFeign;

                    @RequestMapping("/goSettlement")
                    public Result goSettlement(String[] ids, String userId) {
                        //获取购物车
                        Map<String, TbItem> cart = cartServiceFeign.selectCartByUserId(userId);
                        //从购物车中获取选中的商品
                        List<TbItem> list = new ArrayList<TbItem>();
                        for (String id : ids) {
                            list.add(cart.get(id));
                        }
                        if(list.size()>0) {
                            return Result.ok(list);
                        }
                        return Result.error("error");
                    }
                }

2020.6.17日报
    提交订单:
        生成订单号：时间戳+用户id +店铺id
        保存订单信息
            a、在订单确认页面点击“提交订单”按钮生成订单。
            b、请求的url：/frontend/order/insertOrder
            c、参数：订单、订单商品、订单物流
            d、返回值：{"status":200,"msg":"OK","data":"订单ID"}

            @Override
            public String insertOrder(OrderInfo orderInfo) {
                //1、解析orderInfo
                TbOrder tbOrder = orderInfo.getTbOrder();
                TbOrderShipping tbOrderShipping = orderInfo.getTbOrderShipping();
                List<TbOrderItem> tbOrderItemList =
                    JsonUtils.jsonToList(orderInfo.getOrderItem(), TbOrderItem.class);

                //2、保存订单信息
                if(!redisClient.exists(ORDER_ID_KEY)){
                    redisClient.set(ORDER_ID_KEY,ORDER_ID_BEGIN);
                }
                Long orderId = redisClient.incr(ORDER_ID_KEY, 1L);
                tbOrder.setOrderId(orderId.toString());
                Date date = new Date();
                tbOrder.setCreateTime(date);
                tbOrder.setUpdateTime(date);
                //1、未付款，2、已付款，3、未发货，4、已发货，5、交易成功，6、交易关闭
                tbOrder.setStatus(1);
                tbOrderMapper.insertSelective(tbOrder);

                //3、保存明细信息
                if(!redisClient.exists(ORDER_ITEM_ID_KEY)){
                    redisClient.set(ORDER_ITEM_ID_KEY,0);
                }
                for (int i = 0; i < tbOrderItemList.size(); i++) {
                    Long oderItemId = redisClient.incr(ORDER_ITEM_ID_KEY, 1L);
                    TbOrderItem tbOrderItem =  tbOrderItemList.get(i);
                    tbOrderItem.setId(oderItemId.toString());
                    tbOrderItem.setOrderId(orderId.toString());
                    tbOrderItemMapper.insertSelective(tbOrderItem);
                }

                //4、保存物流信息
                tbOrderShipping.setOrderId(orderId.toString());
                tbOrderShipping.setCreated(date);
                tbOrderShipping.setUpdated(date);
                tbOrderShippingMapper.insertSelective(tbOrderShipping);

                //5、返回订单id
                return orderId.toString();
            }
        }

    扣减库存：
        将消息写入消息队列，业务逻辑以异步的方式运行，加快响应速度
            usian_order_service
                service
                    @Service
                    @Transactional
                    public class OrderServiceImpl implements OrderService {
                        ... ... ...
                        @Autowired
                        private AmqpTemplate amqpTemplate;

                        @Override
                        public Long insertOrder(OrderInfo orderInfo) {
                            /************1、向订单表插入数据。********/
                            ... ... ...
                            /************2、向订单明细表插入数据********/
                            ... ... ...
                            /************3、向订单物流表插入数据。********/
                            ... ... ...

                            //发布消息到mq，完成扣减库存
                            amqpTemplate.convertAndSend("order_exchage","order.add", orderId);

                            /************4、返回订单id********/
                            ... ... ...
                        }
                    }
            usian_item_service
                service
                    /**
                    	 * 修改商品库存数量
                    	 * @param orderId
                    	 * @return
                    	 */
                        @Override
                        public Integer updateTbItemByOrderId(String orderId) {
                            TbOrderItemExample tbOrderItemExample = new TbOrderItemExample();
                            TbOrderItemExample.Criteria criteria = tbOrderItemExample.createCriteria();
                            criteria.andOrderIdEqualTo(orderId);
                            List<TbOrderItem> tbOrderItemList =
                                	tbOrderItemMapper.selectByExample(tbOrderItemExample);
                            int result = 0;
                            for (int i = 0; i < tbOrderItemList.size(); i++) {
                                TbOrderItem tbOrderItem =  tbOrderItemList.get(i);
                                TbItem tbItem =
                                    tbItemMapper.selectByPrimaryKey(Long.valueOf(tbOrderItem.getItemId()));
                                tbItem.setNum(tbItem.getNum()-tbOrderItem.getNum());
                                result += tbItemMapper.updateByPrimaryKeySelective(tbItem);
                            }
                            return result;
                        }
                listener
                    /**
                         * 监听者接收消息三要素：
                         *  1、queue
                         *  2、exchange
                         *  3、routing key
                         */
                        @RabbitListener(bindings = @QueueBinding(
                            value = @Queue(value="item_queue",durable = "true"),
                            exchange = @Exchange(value="order_exchage",type= ExchangeTypes.TOPIC),
                            key= {"*.*"}
                        ))
                        public void listen(String orderId) throws Exception {
                            System.out.println("接收到消息：" + orderId);
                            Integer result = itemService.updateTbItemByOrderId(orderId);
                            if(!(result>0)){
                                throw new RuntimeException("扣减失败");
                            }
                        }
                    }

